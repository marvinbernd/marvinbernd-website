'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _find = require('babel-runtime/core-js/array/find');

var _find2 = _interopRequireDefault(_find);

exports.default = require_;

var _utils = require('../../utils');

var _lodash = require('lodash.uniq');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reqRegEx = /^\s*(?:\{(.*)\})?\s*(?:(\$?[^\s]+))?\s*(?:-?\s*([^<$]*))?\s*(?:<?\s*(.*)\s*>)?$/;

function require_(env) {
  return {
    name: 'require',

    parse: function parse(text) {
      var match = reqRegEx.exec(text.trim());

      var obj = {
        type: match[1] || 'function',
        name: match[2]
      };

      obj.external = (0, _utils.splitNamespace)(obj.name).length > 1;

      if (obj.name.indexOf('$') === 0) {
        obj.type = 'variable';
        obj.name = obj.name.slice(1);
      }

      if (obj.name.indexOf('%') === 0) {
        obj.type = 'placeholder';
        obj.name = obj.name.slice(1);
      }

      if (match[3]) {
        obj.description = match[3].trim();
      }

      if (match[4]) {
        obj.url = match[4];
      }

      return obj;
    },
    autofill: function autofill(item) {
      var type = item.context.type;

      if (type === 'mixin' || type === 'placeholder' || type === 'function') {
        var handWritten = void 0;

        if (item.require) {
          handWritten = {};

          item.require.forEach(function (reqObj) {
            handWritten[reqObj.type + '-' + reqObj.name] = true;
          });
        }

        var mixins = searchForMatches(item.context.code, /@include\s+([^(;$]*)/ig, isAnnotatedByHand.bind(null, handWritten, 'mixin'));

        var functions = searchForMatches(item.context.code, new RegExp('(@include)?\\s*([a-z0-9_-]+)\\s*\\(', 'ig'), // Literal destorys Syntax
        isAnnotatedByHand.bind(null, handWritten, 'function'), 2 // Get the second matching group instead of 1
        );

        var placeholders = searchForMatches(item.context.code, /@extend\s*%([^;\s]+)/ig, isAnnotatedByHand.bind(null, handWritten, 'placeholder'));

        var variables = searchForMatches(item.context.code, /\$([a-z0-9_-]+)/ig, isAnnotatedByHand.bind(null, handWritten, 'variable'));

        // Create object for each required item.
        mixins = mixins.map(typeNameObject('mixin'));
        functions = functions.map(typeNameObject('function'));
        placeholders = placeholders.map(typeNameObject('placeholder'));
        variables = variables.map(typeNameObject('variable'));

        // Merge all arrays.
        var all = [].concat(mixins, functions, placeholders, variables);

        // Merge in user supplyed requires if there are any.
        if (item.require && item.require.length > 0) {
          all = all.concat(item.require);
        }

        // Filter empty values.
        all = all.filter(function (x) {
          return x !== undefined;
        });

        if (all.length > 0) {
          all = (0, _lodash2.default)(all, 'name');

          // Filter the item itself.
          all = all.filter(function (x) {
            return !(x.name === item.context.name && x.type === item.context.type);
          });

          return all;
        }
      }
    },
    resolve: function resolve(data) {
      data.forEach(function (item) {
        if (item.require === undefined) {
          return;
        }

        item.require = item.require.map(function (req) {
          if (req.external === true) {
            return req;
          }

          var reqItem = (0, _find2.default)(data, function (x) {
            return x.context.name === req.name && x.context.type === req.type;
          });

          if (reqItem === undefined) {
            if (!req.autofill) {
              env.logger.warn('Item `' + item.context.name + '` requires `' + req.name + '` from type `' + req.type + '` but this item doesn\'t exist.');
            }

            return;
          }

          if (!Array.isArray(reqItem.usedBy)) {
            reqItem.usedBy = [];

            reqItem.usedBy.toJSON = function () {
              return reqItem.usedBy.map(function (item) {
                return {
                  description: item.description,
                  context: item.context
                };
              });
            };
          }

          reqItem.usedBy.push(item);
          req.item = reqItem;

          return req;
        }).filter(function (x) {
          return x !== undefined;
        });

        if (item.require.length > 0) {
          item.require.toJSON = function () {
            return item.require.map(function (item) {
              var obj = {
                type: item.type,
                name: item.name,
                external: item.external
              };

              if (item.external) {
                obj.url = item.url;
              } else {
                obj.description = item.description;
                obj.context = item.context;
              }

              return obj;
            });
          };
        }
      });
    },


    alias: ['requires']
  };
}

function isAnnotatedByHand(handWritten, type, name) {
  if (type && name && handWritten) {
    return handWritten[type + '-' + name];
  }

  return false;
}

function searchForMatches(code, regex, isAnnotatedByHandProxy) {
  var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  var match = void 0;
  var matches = [];

  while (match = regex.exec(code)) {
    if (!isAnnotatedByHandProxy(match[id]) && (id <= 1 || match[id - 1] === undefined)) {
      matches.push(match[id]);
    }
  }

  return matches;
}

function typeNameObject(type) {
  return function (name) {
    if (name.length > 0) {
      return {
        type: type,
        name: name,
        autofill: true
      };
    }
  };
}