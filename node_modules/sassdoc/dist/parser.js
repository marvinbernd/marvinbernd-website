'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _utils = require('./utils');

var _errors = require('./errors');

var errors = _interopRequireWildcard(_errors);

var _annotation = require('./annotation');

var _annotation2 = _interopRequireDefault(_annotation);

var _sorter = require('./sorter');

var _sorter2 = _interopRequireDefault(_sorter);

var _scssCommentParser = require('scss-comment-parser');

var _scssCommentParser2 = _interopRequireDefault(_scssCommentParser);

var _through = require('through2');

var _through2 = _interopRequireDefault(_through);

var _concatStream = require('concat-stream');

var _concatStream2 = _interopRequireDefault(_concatStream);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Parser = function () {
  function Parser(env, additionalAnnotations) {
    (0, _classCallCheck3.default)(this, Parser);

    this.annotations = new _annotation2.default(env);
    this.annotations.addAnnotations(additionalAnnotations);
    this.scssParser = new _scssCommentParser2.default(this.annotations.list, env);
    this.includeUnknownContexts = env.theme && env.theme.includeUnknownContexts;

    this.scssParser.commentParser.on('warning', function (warning) {
      env.emit('warning', new errors.Warning(warning.message));
    });
  }

  (0, _createClass3.default)(Parser, [{
    key: 'parse',
    value: function parse(code, id) {
      return this.scssParser.parse(code, id);
    }

    /**
     * Invoke the `resolve` function of an annotation if present.
     * Called with all found annotations except with type "unknown".
     */

  }, {
    key: 'postProcess',
    value: function postProcess(data) {
      var _this = this;

      data = (0, _sorter2.default)(data);
      var promises = [];

      (0, _keys2.default)(this.annotations.list).forEach(function (key) {
        var annotation = _this.annotations.list[key];

        if (annotation.resolve) {
          var promise = _promise2.default.resolve(annotation.resolve(data));
          promises.push(promise);
        }
      });

      return _promise2.default.all(promises).then(function () {
        return data;
      });
    }

    /**
     * Return a transform stream meant to be piped in a stream of SCSS
     * files. Each file will be passed-through as-is, but they are all
     * parsed to generate a SassDoc data array.
     *
     * The returned stream has an additional `promise` property, containing
     * a `Promise` object that will be resolved when the stream is done and
     * the data is fulfiled.
     *
     * @param {Object} parser
     * @return {Object}
     */

  }, {
    key: 'stream',
    value: function stream() {
      var _this2 = this;

      var deferred = (0, _utils.defer)();
      var data = [];

      var transform = function transform(file, enc, cb) {
        // Pass-through.
        cb(null, file);

        var parseFile = function parseFile(_ref) {
          var buf = _ref.buf,
              name = _ref.name,
              path = _ref.path;

          var fileData = _this2.parse(buf.toString(enc), name);

          fileData.forEach(function (item) {
            item.file = {
              path: path,
              name: name
            };

            data.push(item);
          });
        };

        if (file.isBuffer()) {
          var args = {
            buf: file.contents,
            name: _path2.default.basename(file.relative),
            path: file.relative
          };

          parseFile(args);
        }

        if (file.isStream()) {
          file.pipe((0, _concatStream2.default)(function (buf) {
            parseFile({ buf: buf });
          }));
        }
      };

      var flush = function flush(cb) {
        if (!_this2.includeUnknownContexts) {
          data = data.filter(function (item) {
            return item.context.type !== 'unknown';
          });
        }
        _this2.postProcess(data).then(function (processed) {
          data = processed;
          deferred.resolve(data);
          cb();
        });
      };

      var filter = _through2.default.obj(transform, flush);
      filter.promise = deferred.promise;

      return filter;
    }
  }]);
  return Parser;
}();

exports.default = Parser;