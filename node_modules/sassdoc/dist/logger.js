'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

exports.checkLogger = checkLogger;

var _utils = require('./utils');

var _errors = require('./errors');

var errors = _interopRequireWildcard(_errors);

var _util = require('util');

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var chalk = new _chalk2.default.constructor({
  enabled: process.stderr && process.stderr.isTTY
});

// Special chars.
var chevron = '\xBB';
var checkmark = '\u2713';
var green = chalk.green(chevron);
var yellow = chalk.yellow(chevron);
var red = chalk.red(chevron);

var Logger = function () {
  function Logger() {
    var verbose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    (0, _classCallCheck3.default)(this, Logger);

    this.verbose = verbose;
    this._stderr = process.stderr;
    this._debug = debug;
    this._times = [];
  }

  /**
   * Log arguments into stderr if the verbose mode is enabled.
   */


  (0, _createClass3.default)(Logger, [{
    key: 'log',
    value: function log() {
      if (this.verbose) {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var str = _util.format.apply(undefined, [green + ' ' + args.shift()].concat(args));
        this._stderr.write(str + '\n');
      }
    }

    /**
     * Always log arguments as warning into stderr.
     */

  }, {
    key: 'warn',
    value: function warn() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var str = _util.format.apply(undefined, [yellow + ' [WARNING] ' + args.shift()].concat(args));
      this._stderr.write(str + '\n');
    }

    /**
     * Always log arguments as error into stderr.
     */

  }, {
    key: 'error',
    value: function error() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var str = _util.format.apply(undefined, [red + ' [ERROR] ' + args.shift()].concat(args));
      this._stderr.write(str + '\n');
    }

    /**
     * Init a new timer.
     * @param {String} label
     */

  }, {
    key: 'time',
    value: function time(label) {
      this._times[label] = Date.now();
    }

    /**
     * End timer and log result into stderr.
     * @param {String} label
     * @param {String} format
     */

  }, {
    key: 'timeEnd',
    value: function timeEnd(label) {
      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '%s: %dms';

      if (!this.verbose) {
        return;
      }

      var time = this._times[label];
      if (!time) {
        throw new Error('No such label: ' + label);
      }

      var duration = Date.now() - time;

      var str = (0, _util.format)(chalk.green(checkmark) + ' ' + format, label, duration);
      this._stderr.write(str + '\n');
    }

    /**
     * Log arguments into stderr if debug mode is enabled (will call all
     * argument functions to allow "lazy" arguments).
     */

  }, {
    key: 'debug',
    value: function debug() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (!this._debug) {
        return;
      }

      args = args.map(function (f) {
        if (f instanceof Function) {
          return f();
        }

        return f;
      });

      var str = _util.format.apply(undefined, ['' + _chalk2.default.styles.grey.open + chevron + ' [DEBUG] ' + args.shift()].concat((0, _toConsumableArray3.default)(args), [_chalk2.default.styles.grey.close]));

      this._stderr.write(str + '\n');
    }
  }]);
  return Logger;
}();

exports.default = Logger;
var empty = exports.empty = {
  log: function log() {},
  warn: function warn() {},
  error: function error() {},
  debug: function debug() {}

  /**
   * Checks if given object looks like a logger.
   *
   * If the `debug` function is missing (like for the `console` object),
   * it will be set to an empty function in a newly returned object.
   *
   * If any other method is missing, an exception is thrown.
   *
   * @param {Object} logger
   * @return {Logger}
   * @throws {SassDocError}
   */
};function checkLogger(logger) {
  var methods = ['log', 'warn', 'error'].filter(function (x) {
    return !(x in logger) || !_utils.is.function(logger[x]);
  });

  if (methods.length) {
    var missing = '"' + methods.join('\`, \`') + '"';
    var s = methods.length > 1 ? 's' : '';

    throw new errors.SassDocError('Invalid logger, missing ' + missing + ' method' + s);
  }

  if ('debug' in logger) {
    return logger;
  }

  return {
    log: logger.log,
    warn: logger.warn,
    error: logger.error,
    debug: empty.debug
  };
}